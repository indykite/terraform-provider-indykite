---
# generated by https://github.com/hashicorp/terraform-plugin-docs with custom templates
page_title: "indykite_knowledge_query Resource - IndyKite"
subcategory: ""
description: |-
  Creating Policy:  An authorization admin starts by creating a new subgraph or selecting an existing one as the container for the policy they wish to create. Next, the admin specifies a set of nodes and relationships within the subgraph and  specifies the static filters and partial filters on the selected nodes and relationship.  There must be exactly one node that is specified as the Subject node.  However, two separate policies may contain two different Subject nodes.  Note that not every node and relationship needs a filter or partial filter.  The nodes and relationships, along with the filters and partial filters,  form the necessary requirements for the queries that will be defined in the context of this policy.  Creating Query:  Every query is created in the context of a policy.  While the policy describes the requirements, the query focuses on retrieving data.  The policy admin starts by selecting a subgraph and a policy for the context of the query.  The admin then specifies the read, upsert, and delete components for the query.  When the admin is done specifying the query, the query combined with the policy are translated to Cypher.
---

# indykite_knowledge_query (Resource)

**Creating Policy:**  <br>An authorization admin starts by creating a new subgraph or selecting an existing one as the container for the policy they wish to create. Next, the admin specifies a set of nodes and relationships within the subgraph and  specifies the static filters and partial filters on the selected nodes and relationship.  There must be exactly one node that is specified as the Subject node.  However, two separate policies may contain two different Subject nodes.  Note that not every node and relationship needs a filter or partial filter.  The nodes and relationships, along with the filters and partial filters,  form the necessary requirements for the queries that will be defined in the context of this policy.  <br>**Creating Query:**  <br>Every query is created in the context of a policy.  While the policy describes the requirements, the query focuses on retrieving data.  The policy admin starts by selecting a subgraph and a policy for the context of the query.  The admin then specifies the read, upsert, and delete components for the query.  When the admin is done specifying the query, the query combined with the policy are translated to Cypher.

## Example Usage

```terraform
resource "indykite_authorization_policy" "policy_for_ciq" {
  name         = "terraform-pipeline-policy-for-ciq"
  display_name = "Terraform policy for CIQ"
  description  = "Policy for CIQ in terraform pipeline"
  json = jsonencode({
    "meta" : { "policy_version" : "1.0-ciq" },
    "subject" : { "type" : "Person" },
    "condition" : {
      "cypher" : "MATCH (subject:Person)-[r1:ACCEPTED]->(contract:Contract)-[r2:COVERS]->(vehicle:Vehicle)-[r3:HAS]->(ln:LicenseNumber)",
      "filter" : [{ "app" : "app1", "attribute" : "subject.property.username", "operator" : "=", "value" : "$username" }]
    },
    "allowed_reads" : {
      "nodes" : ["ln.property.value", "ln.property.transferrable", "ln.external_id"],
      "relationships" : ["r1"]
    }
  })
  location = "AppSpaceID"
  status   = "active"

}

resource "indykite_knowledge_query" "create-query" {
  name         = "terraform-knowledge-query"
  display_name = "Terraform knowledge-query"
  description  = "Knowledge query for terraform"
  location     = "AppSpaceID"
  query = jsonencode({
    "nodes" : ["ln.property.value"],
    "relationships" : [],
    "filter" : { "attribute" : "ln.property.value", "operator" : "=", "value" : "$lnValue" }
  })

  status    = "active"
  policy_id = indykite_authorization_policy.policy_for_ciq.id
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `location` (String) Identifier of Location, where to create resource
- `name` (String) Unique client assigned immutable identifier. Can not be updated without creating a new resource.
- `policy_id` (String) ID of the Authorization Policy that is used to authorize the query.
- `query` (String) Configuration of Knowledge Query in JSON format, the same one exported by The Hub.
- `status` (String) Status of the Knowledge Query. Possible values are: active, draft, inactive.

### Optional

- `description` (String) Your own description of the resource. Must be less than or equal to 256 UTF-8 bytes.
- `display_name` (String) The display name for the instance. Can be updated without creating a new resource.
- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))

### Read-Only

- `app_space_id` (String) Identifier of Application Space
- `create_time` (String) Timestamp when the Resource was created. Assigned by the server. A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
- `customer_id` (String) Identifier of Customer
- `id` (String) The ID of this resource.
- `update_time` (String) Timestamp when the Resource was last updated. Assigned by the server. A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".

<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `create` (String)
- `default` (String)
- `delete` (String)
- `read` (String)
- `update` (String)


