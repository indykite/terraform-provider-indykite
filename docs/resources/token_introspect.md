---
# generated by https://github.com/hashicorp/terraform-plugin-docs with custom templates
page_title: "indykite_token_introspect Resource - IndyKite"
subcategory: ""
description: |-
  Token introspect configuration adds support for 3rd party tokens to identify the user within IndyKite APIs.
  Token introspect enables the IndyKite platform to identify end users by third party tokens,
  validate these tokens, and use their content in the IndyKite platform.
  To verify these tokens, you need to create a configuration that describes how to do the token introspection.
---

# indykite_token_introspect (Resource)

Token introspect configuration adds support for 3rd party tokens to identify the user within IndyKite APIs.
		Token introspect enables the IndyKite platform to identify end users by third party tokens,
		validate these tokens, and use their content in the IndyKite platform.
		To verify these tokens, you need to create a configuration that describes how to do the token introspection.

## Example Usage

```terraform
# Example - JWT with online validation
resource "indykite_token_introspect" "token1" {
  name         = "terraform-token-introspect"
  display_name = "Terraform token introspect"
  description  = "Token introspect for terraform pipeline"
  location     = "AppSpaceID"
  jwt_matcher {
    issuer   = "https://example.com"
    audience = "audience-id"
  }
  online_validation {
    cache_ttl = 600
  }
  claims_mapping = {
    "email" = "mail",
    "name"  = "full_name"
  }
  ikg_node_type  = "MyUser"
  perform_upsert = true
}

# Example - JWT with offline validation
resource "indykite_token_introspect" "token2" {
  name         = "terraform-token-introspect-offline"
  display_name = "Terraform token introspect offline"
  description  = "Token introspect for terraform pipeline with offline validation"
  location     = "AppSpaceID"
  jwt_matcher {
    issuer   = "https://example.com"
    audience = "audience-id"
  }
  offline_validation {
    public_jwks = [
      jsonencode({
        "kid" : "abc",
        "use" : "sig",
        "alg" : "RS256",
        "n" : "--nothing-real-just-random-xyqwerasf--",
        "kty" : "RSA"
      }),
      jsonencode({
        "kid" : "jkl",
        "use" : "sig",
        "alg" : "RS256",
        "n" : "--nothing-real-just-random-435asdf43--",
        "kty" : "RSA"
      })
    ]
  }
  ikg_node_type = "MyUser"
  sub_claim     = "custom_sub"
}

# Example 1: Minimal JWT with online validation and hardcoded location
resource "indykite_token_introspect" "minimal_online" {
  name     = "minimal-online-jwt"
  location = "gid:AAAAAmluZHlraURlgAABDwAAAAA"
  jwt_matcher {
    issuer   = "https://auth.example.com"
    audience = "my-app"
  }
  online_validation {
    cache_ttl = 300
  }
  ikg_node_type = "User"
}

# Example 2: JWT with online validation and reference to application_space
resource "indykite_token_introspect" "online_with_ref" {
  name         = "online-jwt-with-ref"
  display_name = "Online JWT with Reference"
  description  = "JWT token introspect with online validation using app space reference"
  location     = indykite_application_space.my_space.id
  jwt_matcher {
    issuer   = "https://auth.example.com"
    audience = "my-application"
  }
  online_validation {
    cache_ttl = 600
  }
  claims_mapping = {
    "email"       = "user_email",
    "name"        = "user_name",
    "given_name"  = "first_name",
    "family_name" = "last_name"
  }
  ikg_node_type  = "Person"
  perform_upsert = true
}

# Example 3: JWT with offline validation and reference
resource "indykite_token_introspect" "offline_with_ref" {
  name         = "offline-jwt-with-ref"
  display_name = "Offline JWT with Reference"
  description  = "JWT token introspect with offline validation"
  location     = indykite_application_space.my_space.id
  jwt_matcher {
    issuer   = "https://auth.example.com"
    audience = "my-app-offline"
  }
  offline_validation {
    public_jwks = [
      jsonencode({
        "kid" : "key-1",
        "use" : "sig",
        "alg" : "RS256",
        "n" : "--public-key-modulus-here--",
        "kty" : "RSA"
      })
    ]
  }
  ikg_node_type = "User"
  sub_claim     = "user_id"
}

# Example 4: JWT with custom claims mapping
resource "indykite_token_introspect" "custom_claims" {
  name         = "jwt-custom-claims"
  display_name = "JWT with Custom Claims"
  description  = "Token introspect with extensive claims mapping"
  location     = indykite_application_space.my_space.id
  jwt_matcher {
    issuer   = "https://auth.example.com"
    audience = "custom-app"
  }
  online_validation {
    cache_ttl = 900
  }
  claims_mapping = {
    "email"        = "email_address",
    "name"         = "full_name",
    "given_name"   = "first_name",
    "family_name"  = "last_name",
    "phone_number" = "phone",
    "address"      = "postal_address"
  }
  ikg_node_type  = "Person"
  perform_upsert = true
  sub_claim      = "user_identifier"
}

# Note: The location parameter accepts an Application Space ID.
# You must use either jwt_matcher or opaque_matcher (not both).
# You must use either online_validation or offline_validation (not both).
# The token introspect will automatically populate app_space_id and customer_id as computed fields.
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `ikg_node_type` (String) Node type in IKG to which we will try to match sub claim with DT external_id.
- `location` (String) Identifier of Location, where to create resource
- `name` (String) Unique client assigned immutable identifier. Can not be updated without creating a new resource.

### Optional

- `claims_mapping` (Map of String) ClaimsMapping specifies which claims from the token should be mapped to new names and name of property in IKG.
    Be aware, that this can override any existing claims, which might not be accessible anymore by internal services.
    And with the highest priority, there is mapping of sub claim to 'external_id'. So you shouldn't ever use 'external_id' as a key.

    Key specifies the new name and also the name of the property in IKG.
    Value specifies which claim to map and how.
- `description` (String) Your own description of the resource. Must be less than or equal to 65000 UTF-8 bytes.
- `display_name` (String) The display name for the instance. Can be updated without creating a new resource.
- `jwt_matcher` (Block List, Max: 1) Specifies all attributes required to match a JWT token. (see [below for nested schema](#nestedblock--jwt_matcher))
- `offline_validation` (Block List, Max: 1) Offline validation works only with JWT and checks token locally. (see [below for nested schema](#nestedblock--offline_validation))
- `online_validation` (Block List, Max: 1) Online validation works with both JWT and Opaque tokens. It will call userinfo endpoint to validate token and fetch user claims. (see [below for nested schema](#nestedblock--online_validation))
- `opaque_matcher` (Block List, Max: 1) Specify opaque token matcher. Currently we support only 1 opaque matcher per application space. (see [below for nested schema](#nestedblock--opaque_matcher))
- `perform_upsert` (Boolean) Perform Upsert specify, if we should create and/or update DigitalTwin in IKG if it doesn't exist with.
	In future this will perform upsert also on properties that are derived from token.
- `sub_claim` (String) Sub claim is used to match DigitalTwin with external_id. If not specified, standard 'sub' claim will be used. Either 'sub' or specified claim will then also be mapped to 'external_id' claim.
- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))

### Read-Only

- `app_space_id` (String) Identifier of Application Space
- `create_time` (String) Timestamp when the Resource was created. Assigned by the server. A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
- `created_by` (String) Identifier of the user who created the resource
- `customer_id` (String) Identifier of Customer
- `id` (String) The ID of this resource.
- `update_time` (String) Timestamp when the Resource was last updated. Assigned by the server. A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
- `updated_by` (String) Identifier of the user who last updated the resource

<a id="nestedblock--jwt_matcher"></a>
### Nested Schema for `jwt_matcher`

Required:

- `audience` (String) Audience is used to exact match based on `aud` claim in JWT.
- `issuer` (String) Issuer is used to exact match based on `iss` claim in JWT.


<a id="nestedblock--offline_validation"></a>
### Nested Schema for `offline_validation`

Optional:

- `public_jwks` (List of String) Public JWKs to validate signature of JWT. If there are no public keys specified, they will be fetched and cached from jwks_uri at https://jwt-issuer.tld/.well-known/openid-configuration


<a id="nestedblock--online_validation"></a>
### Nested Schema for `online_validation`

Optional:

- `cache_ttl` (Number) Cache TTL of token validity can be used to minimize calls to userinfo endpoint.
    The final cache TTL will be set to lower limit of this value and exp claim of JWT token.
    If not set, token will not be cached and call to userinfo endpoint will be made on every request.

    However, token validity will be checked first if possible (JWT tokens).
    If token is expired, userinfo endpoint will not be called, nor cache checked.
- `user_info_endpoint` (String) URI of userinfo endpoint which will be used to validate access token.
    And also fetch user claims when opaque token is received

    It can remain empty, if JWT token matcher is used.
    Then the URI under "userinfo_endpoint" in .well-known/openid-configuration endpoint is used.


<a id="nestedblock--opaque_matcher"></a>
### Nested Schema for `opaque_matcher`

Required:

- `hint` (String) To differentiate between multiple opaque tokens configurations, hint must be provided. Hint is case sensitive plain text, that is expected to be provided in token introspect request, if there are multiple opaque tokens configurations.


<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `create` (String)
- `default` (String)
- `delete` (String)
- `read` (String)
- `update` (String)
